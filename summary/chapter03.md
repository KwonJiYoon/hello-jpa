### Chpaer03 - 영속성 관리
<br>

><b> 엔티티 매니저 팩토리와 엔티티 매니저 </b> <br>
엔티티 매니저 팩토리는 엔티티 매니저를 만드는 공장이라고 생각할 수 있고, 비용이 많이 들기때문에<br>
한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계가 되어있다.<br>
엔티티 매니저 팩토리는 <b>여러 스레드가 동시에 접근해도 안전하여 서로 다른 스레드 간에 공유가 가능하다.</b><br>
엔티티 매니저는 <b>여러 스레드가 동시에 접근하면 동시성 문제가 발생해서 스레드 간 공유는 불가능하다.</b><br>
하이버네이트를 포함한 JPA 구현체들은 EntityManagerFactory를 생성할 때 커넥션 풀도 만든다. (J2SE에서 사용하는 방법)

<br>

><b> 영속성 컨텍스트란 ❓ </b> <br>
영속성 컨텍스트의 뜻은 <b>'엔티티를 영구 저장하는 환경'</b>이다.<br>
엔티티 매니저로 엔티티를 저장 / 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 저장 / 보관한다.<br>
```java
em.persist(member);
```
chapter02에서 위 코드를 단순히 회원 엔티티를 저장하는 것이라고 표현했지만,<br>
persist() 메소드는 <b>엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다.</b><br>
영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나가 만들어진다.<br>
엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고, 관리할 수 있다.<br>
여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수도 있다.

<br>

><b> 엔티티와 생명주기 </b> <br>

 * <b>비영속(new/transient) : </b> 영속성 컨텍스트와 전혀 관계가 없는 상태<br><br>
 * <b>영속(managed) : </b> 영속성 컨텍스트에 저장된 상태<br><br>
 * <b>준영속(detached) : </b> 영속성 컨텍스트에 저장되었다가 분리된 상태<br><br>
 * <b>삭제(removed) : </b> 삭제된 상태<br><br>
 
#### 비영속
``` java
// 객체를 생성한 상태 (비영속)
Member member = new Member();
member.setId("member1");
member.setUserName("회원1");
```
엔티티 객체를 생성한 상태는 순수한 객체 상태이며 아직 저장하지 않았기 때문에 영속성 컨텍스트나 데이터베이스와는<br>
관련이 없다.
<br><br>

#### 영속
```java
// 객체를 저장한 상태 (영속)
em.persist(member);
```
엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장하여 <b>영속성 컨텍스트가 관리하는 엔티티를 영속 상태</b>라고 한다.<br>
<b>영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 뜻이다.</b><br>
em.find()나 JPQL을 사용해서 조회한 엔티티도 영속성 컨텍스트가 된리하는 영속 상태이다.
<br><br>

#### 준영속
```java
// 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
em.detach(member);
```
영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.<br>
특정 엔티티를 준영속 상태로 만들기 위해서는 em.detach()를 호출하면 된다. <br>
detach() 메소드 말고도 em.close() 나 em.clear()를 호출해서 영속성 컨텍스트를 초기화해도 영속성 컨텍스트가<br>
관리하던 영속 상태의 엔티티는 준영속 상태가 된다.
<br><br>

#### 삭제 
```java
// 객체를 삭제한 상태 (삭제)
em.remove(member);
```
엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.
<br><br><br>

><b> 영속성 컨텍스트의 특징 </b> <br>
* 영속성 컨텍스트는 엔티티를 식별자 값으로 구분하기 때문에 <b>영속 상태는 식별자 값이 반드시 있어야한다.</b><br>
식별자 값 없으면 예외 발생.<br><br>

* 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한다. :: 플러시(flush)<br><br>
* 영속성 컨텍스트가 엔티티를 관리할 때의 장점
  * 1차 캐시
  * 동일성 보장
  * 트랜잭션을 지원하는 쓰기 지원
  * 변경 감지
  * 지연 로딩
  <br><br><br>


#### _엔티티 조회_ <br>
1차 캐시란, 영속성 컨텍스트가 내부에 캐시를 가지고 있는 것이다. <br>
영속 상태의 엔티티는 모두 이곳에 저장된다. 간단하게 보면 영속성 컨텍스트 내부에 Map이 있고 키는 @Id로 매핑한 식별자,<br>
값을 엔티티 인스턴스이다.
```java
// 객체를 생성한 상태 (비영속)
Member member = new Member();
member.setId("member1");
member.setUserName("회원1");

// 엔티티를 영속
em.persist(member);
```
위 코드에서는 1차 개시에 회원 엔티티를 저장하며, 회원 엔티티는 아직 데이터베이스에 저장되지는 않았다.<br>
1채 캐시의 키는 식별자 값이다. 식별자 값은 데이터베이스 기본키와 매핑되어 있어서, 영속성 컨텍스트에 데이터를 저장하고 조회하는<br>
모든 기준은 데이터베이스 기본 키 값이다.<br>
```java
Member member = em.find(Member.class, "member1");
```
em.find()를 호출하면 1차 캐시에서 엔티티를 찾고, 찾고싶은 엔티티가 1차 캐시에 없으면 데이터베이스에서 조회한다.
```java
// EntitiyManager.find() 메소드 정의
public<T> T find(Class<T> entityClass, Object primaryKey);
```
find() 메소드에서 첫 번째 파라미터는 엔티티 클래스의 타입이고, 두 번째는 조회할 엔티티의 식별자 값이다.

<br><br>

#### _영속 엔티티의 동일성 보장_
```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

// 동일성 비교
System.out.println(a == b);
```
em.find(Member.class, "member1") 이 코드를 반복하여 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다.<br>
따라서 둘은 같은 인스턴스이고 결과는 참이다. <br>
<b>영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.</b>

* 동일성 (identity) : 실제 인스턴스가 같다. 참조 값을 비교하는 == 비교의 값이 같다.
* 동등성 (equality) : 실제 인스턴스는 다를 수 있지만, 인스턴스가 가지고 있는 값이 같다. 동등성 비교는 equals() 메소드를 사용한다.

<br><br>

#### _엔티티 등록_
```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();

// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야한다.
transaction.begin();        // [트랜잭션] 시작

em.persist(memberA);
em.persist(memberB);
// 여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.

// 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
transaction.commit();       // [트랜잭션] 커밋
```
엔티티 매니저는 트랜잭션을 커밋하기 직전까지는 데이터베이스에 엔티티를 저장하지 않고, 내부 쿼리 저장소에 INSERT SQL을 모아둔다.<br>
트랜잭션 커밋 시 모다운 쿼리를 데이터베이스에 보내는데, 이것을 트랜잭션을 지원하는 쓰기 지연이라고 한다.
트랜잭션을 커밋하면 엔티티 매니저는 영속성 컨텍스트를 플러시한다.<br>

플러시란❓<br>
영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업인데, 이때 등록/수정/삭제한 엔티티를 데이터베이스에 반영한다.<br>
쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보내는 것이다. <br><br>
이렇게 영속성 컨텍스트의 변경 내용을 데이터 베이스에 동기화한 후, 실제 데이터베이스 트랜잭션을 커밋한다.

<br>

#### _트랜잭션을 지원하는 쓰기 지연이 가능한 이유_

1. 데이터를 저장하는 즉시 등록 쿼리를 데이터베이스에 보내고, 마지막에 트랜잭션을 커밋한다.
2. 데이터를 저장하면 등록 쿼리를 바로 보내지 않고 메모리에 모아둔 후 트랜잭션 커밋 시 모아둔 등록 쿼리를 보낸 후에 커밋한다.
<br><br>

위 두가지 경우 모두 트랜잭션 범위 안에서 실행되기 때문에 결과는 같다 .<br>
등록 쿼리를 저장할 때마다 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 아무런 소용이 없다. <br>
순서에 상관 없이 커밋 직전에만 데이터베이스에 SQL을 전달하면 되고, 이것이 트랜잭션을 지원하는 쓰기 지연이 가능한 이유이다.
<br><br>

#### _엔티티 수정_
```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();

// [트랜잭션] 시작
transaction.begin();

// 영속 엔티티 조회
Member memberA = em.find(Member.class, "memberA");

// 영속 엔티티 데이터 수정
memberA.setUsername("hi");
memberA.setAge(10);

transaction.commit();       // [트랜잭션] 커밋
```
JPA로 엔티티를 수정할 경우, 단순히 엔티티를 조회하고 데이터만 변경하면 수정된다.<br>
이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능이 <b>변경 감지</b>이다.<br><br>
JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해둔다. (스냅샷)<br>
그리고 플러시 시점에 스냅샷과 엔티티를 비교하여 변경이 발생한 엔티티를 찾는다.<br><br>
<b>변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.</b><br>
비영속, 준영속처럼 영속성 컨텍스트의 관리를 받지 못하는 엔티티는 값을 변경해도 데이터베이스에 반영되지 않는다.
```mysql
UPDATE MEMBER
SET
    NAME = ?,
    AGE = ?,
    GRADE = ?
WHERE ID = ?
```
**JPA의 기본 전략은 엔티티의 모든 필드를 업데이트한다.**<br><br>
< 모든 필드를 업데이트 하는 이유 >
* 모든 필드를 사용하면 바인딩 되는 데이터는 다르지만, 수정 쿼리가 항상 같아서 애플리케이션 로딩 시 수정쿼리를 미리 생성해두고 재사용이 가능하다.
* 데이터베이스에 동일한 쿼리를 보내면 이전에 파싱된 쿼리를 재사용할 수 있다.
  <br>

물론 모든 필드를 사용하면 데이터베이스에 보내는 데이터 전송량이 증가하는 단점도 존재한다.<br>
필드가 많거나 저장되는 내용이 큰 경우엔 하이버네이트 확장 기능을 사용하여 수정된 데이터만 수정하는 동적 UPDATE SQL을 생성하는 방법을 선택하면 된다.<br>

```java
@org.hibernate.anootation.DynamicUpdate
```
엔티티 클래스에 위 어노테이션을 사용하면 수정된 데이터만 사용하여 동적으로 UPDATE SQL을 생성한다.<br>
데이터를 저장할 때 Null이 아닌 필드만으로 INSERT SQL을 동적으로 생성하는 @DynamicInsert도 있다.
<br>
<br>
#### _엔티티 수정_
```java
// 삭제 대상 엔티티 조회
Member memberA = em.find(Member.class, "memberA");

// 엔티티 삭제
em.remove(memberA);
```
엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다.<br>
em.remove()에 삭제할 엔티티를 넘겨주면 엔티티가 삭제된다. <br>
물론 바로 삭제되는 것이 아닌, 등록과 마찬가지고 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록한 후 트랜잭션 커밋 시 플러시를 호출하면<br>
실제 데이터베이스에 삭제 쿼리를 전달한다.<br>
하지만 em.remove(memberA)를 호출하는 순간 memberA는 영속성 컨텍스트에서 제거된다.<br>
이렇게 삭제된 엔티티는 재사용하지 말고 가비지 컬렉션의 대상이 되도록 두는 것이 좋다.


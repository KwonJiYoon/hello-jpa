### Chpaer03 - 영속성 관리
<br>

><b> 엔티티 매니저 팩토리와 엔티티 매니저 </b> <br>
엔티티 매니저 팩토리는 엔티티 매니저를 만드는 공장이라고 생각할 수 있고, 비용이 많이 들기때문에<br>
한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계가 되어있다.<br>
엔티티 매니저 팩토리는 <b>여러 스레드가 동시에 접근해도 안전하여 서로 다른 스레드 간에 공유가 가능하다.</b><br>
엔티티 매니저는 <b>여러 스레드가 동시에 접근하면 동시성 문제가 발생해서 스레드 간 공유는 불가능하다.</b><br>
하이버네이트를 포함한 JPA 구현체들은 EntityManagerFactory를 생성할 때 커넥션 풀도 만든다. (J2SE에서 사용하는 방법)

<br>

><b> 영속성 컨텍스트란 ❓ </b> <br>
영속성 컨텍스트의 뜻은 <b>'엔티티를 영구 저장하는 환경'</b>이다.<br>
엔티티 매니저로 엔티티를 저장 / 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 저장 / 보관한다.<br>
```java
em.persist(member);
```
chapter02에서 위 코드를 단순히 회원 엔티티를 저장하는 것이라고 표현했지만,<br>
persist() 메소드는 <b>엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다.</b><br>
영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나가 만들어진다.<br>
엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고, 관리할 수 있다.<br>
여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수도 있다.

<br>

><b> 엔티티와 생명주기 </b> <br>

 * <b>비영속(new/transient) : </b> 영속성 컨텍스트와 전혀 관계가 없는 상태<br><br>
 * <b>영속(managed) : </b> 영속성 컨텍스트에 저장된 상태<br><br>
 * <b>준영속(detached) : </b> 영속성 컨텍스트에 저장되었다가 분리된 상태<br><br>
 * <b>삭제(removed) : </b> 삭제된 상태<br><br>
 
#### 비영속
``` java
// 객체를 생성한 상태 (비영속)
Member member = new Member();
member.setId("member1");
member.setUserName("회원1");
```
엔티티 객체를 생성한 상태는 순수한 객체 상태이며 아직 저장하지 않았기 때문에 영속성 컨텍스트나 데이터베이스와는<br>
관련이 없다.
<br><br>

#### 영속
```java
// 객체를 저장한 상태 (영속)
em.persist(member);
```
엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장하여 <b>영속성 컨텍스트가 관리하는 엔티티를 영속 상태</b>라고 한다.<br>
<b>영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 뜻이다.</b><br>
em.find()나 JPQL을 사용해서 조회한 엔티티도 영속성 컨텍스트가 된리하는 영속 상태이다.
<br><br>

#### 준영속
```java
// 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
em.detach(member);
```
영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.<br>
특정 엔티티를 준영속 상태로 만들기 위해서는 em.detach()를 호출하면 된다. <br>
detach() 메소드 말고도 em.close() 나 em.clear()를 호출해서 영속성 컨텍스트를 초기화해도 영속성 컨텍스트가<br>
관리하던 영속 상태의 엔티티는 준영속 상태가 된다.
<br><br>

#### 삭제 
```java
// 객체를 삭제한 상태 (삭제)
em.remove(member);
```
엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.
<br><br><br>
